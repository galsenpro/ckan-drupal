<?php

 /**
  * @file ckan.module
  * Intgration with CKAN data hub.
  */


 /**
  * Defines function signatures for resources available to services.
  *
  * Functionally this is very similar to the way hook_menu() works, and in many
  * ways Services can be seen as an abstraction layer on top of hook_menu().
  *
  * @return
  *   An associative array which defines available resources.
  *
  *   The associative array which defines services has six possible top
  *   level keys:
  *
  *     - create
  *     - retrieve
  *     - update
  *     - delete
  *     - actions
  *     - targeted actions
  *
  *   The first four (the CRUD functions) define the indvidual service
  *   callbacks for each function. However 'actions' and 'targeted actions'
  *   can contain multiple callbacks.
  *
  *   For those familiar with Services 2.x, these callbacks are created
  *   similarly, but the keys have changed around a bit. The following keys
  *   are used to describe a callback.
  *
  *   - help: Text describing what this callback does.
  *   - callback: The name of a function to call when this resource is
  *     requested.
  *   - access callback: The name of a function to call to check whether
  *     the requesting user has permission to access this resource. If not
  *     specified, this defaults to 'user_access'.
  *   - access arguments: The arguments to pass to the access callback.
  *   - access arguments append: A boolean indicating whether the resource's
  *     arguments should be appended to the access arguments. This can be useful
  *     in situations where an access callback is specific to the particular
  *     item ('edit all nodes' vs 'edit my nodes'). Defaults to FALSE.
  *   - args: an array describing the arguments which should be passed to this
  *     resource when it is called. Each element in the array is an associative
  *     array containing the following keys:
  *
  *     - name: The name of this argument.
  *     - type: The data type of this argument (int, string, array)
  *     - description: Text describing this argument's usage.
  *     - optional: A boolean indicating whether or not this argument is optional.
  *     - source: Where this argument should be retrieved from. This can be
  *       'data' (indicating the POST data), 'param' (indicating the query
  *       string) or 'path' (indicating the url path). In the case of path,
  *       an additional parameter must be passed indicating the index to be used.
  *     - default value: this is a value that will be passed to the method for this particular argument if no argument value is passed
  */
function ckan_services_resources() {
  $services = array();

 /*
  *  API for CKAN package management
  *
  *  Index            | Return list of Package nids
  *  Retrieve         | Return the data of a Package node
  *  Create           | Create a bare Package node
  *  Update           | Update (call save on) a Package node. No fields updated.
  *  Delete           | Delete a Package node
  *  Action           |
  *         Save      | Loads and Saves a package node.
  *  Targeted Action  |
  *
  */


  $services['package']['index'] = array(
    'help' => 'index a package',
    'callback' => '_ckanrest_index',
    'access callback' => '_ckanrest_access',
    'file' => array('file' => 'inc', 'module' => 'ckan'),
    'args' => array( ),
  );

  $services['package']['retrieve'] = array(
    'help' => 'Retrieves a package',
    'callback' => '_ckanrest_retrieve',
    'access callback' => '_ckanrest_access',
    'file' => array('file' => 'inc', 'module' => 'ckan'),
    'args' => array(
      array(
        'name' => 'nid',
        'type' => 'int',
        'description' => 'The nid of the ckan package to get',
        'source' => array('path' => '0'),
        'optional' => FALSE,
      ),
    ),
  );

  $services['package']['create'] = array(
    'help' => 'Creates a Package',
    'callback' => '_ckanrest_create',
    'access callback' => '_ckanrest_access',
    'file' => array('file' => 'inc', 'module' => 'ckan'),
    'args' => array(
      array(
        'name' => 'data',
        'type' => 'array',
        'description' => 'The package object',
        'source' => 'data',
        'optional' => FALSE,
      ),
    ),
  );

  $services['package']['update'] = array(
    'help' => 'Update a Package node',
    'callback' => '_ckanrest_update',
    'access callback' => '_ckanrest_access',
    'file' => array('file' => 'inc', 'module' => 'ckan'),
    'args' => array(
      array(
        'name' => 'data',
        'type' => 'int',
        'description' => 'The package node ID',
        'source' => 'data',
        'optional' => FALSE,
      ),
    ),
  );

  $services['package']['delete'] = array(
    'help' => 'Delete a Package node',
    'callback' => '_ckanrest_delete',
    'access callback' => '_ckanrest_access',
    'file' => array('file' => 'inc', 'module' => 'ckan'),
    'args' => array(
      array(
        'name' => 'nid',
        'type' => 'int',
        'description' => 'The nid of the ckan package to get',
        'source' => array('path' => '0'),
        'optional' => FALSE,
      ),
    ),
  );


 /*
  *  Supply a Package nid to save the node.
  *  Needed because of direct drupal databases writes by CKAN
  *
  *  @todo Using actions instead of targed actions because of bugs in services 6.x-3.0-rc1
  */
  $services['package']['actions'] = array(
    'save' => array(
      'help' => 'Loads and Saves a Package node.',
      'callback' => '_ckanrest_save',
      'access callback' => '_ckanrest_access',
      'file' => array('file' => 'inc', 'module' => 'ckan'),
      'args' => array(
        array(
          'name' => 'nid',
          'type' => 'int',
          'description' => 'A valid Package node ID',
          'source' => 'data',
          'optional' => FALSE,
        ),
      ),
    ),
  );

  return $services;
}


/**
 * Access callback for the ckan resource.
 *
 * @return bool
 *  Whether access is given or not.
 */
function  _ckanrest_access() {
	return TRUE;
}

/**
* Implementation of hook_ctools_plugin_api().
*/

function ckan_ctools_plugin_api($owner, $api) {
 return array(
  'version' => 3,
   'file' => 'ckan.services.inc', // Optional parameter to indicate the file name to load.
   'path' => drupal_get_path('module', 'ckan') . '/includes', // If specifying the file key, path is required.
    );
 }


function ckan_views_api(){
  // Note that you can include 'path' in this array so that your views.inc
  // file can be stored in a different location.
  return array(
  	'path' => drupal_get_path('module', 'ckan') . '/includes',
    'api' => 2.0,
  );
}



/**
 * Implementation of hook_node_info().
 */
function ckan_node_info() {
  return array(
    'ckan_package' => array(
      'name' => 'Package',
      'module' => 'ckan',
      'description' => 'A ckan package.',
      'help' => '',
      'min_word_count' => '',
      'locked' => FALSE,
    ),
  );
}


/**
 * Implementation of hook_form().
 *
 * Now it's time to describe the form for collecting the information
 * specific to this node type. This hook requires us to return an array with
 * a sub array containing information for each element in the form.
 */
function ckan_form(&$node, $form_state) {
  // The site admin can decide if this node type has a title and body, and how
  // the fields should be labeled. We need to load these settings so we can
  // build the node form correctly.
  $type = node_get_types('type', $node);

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => check_plain($type->title_label),
    '#required' => TRUE,
    '#default_value' => $node->title,
    '#weight' => -5
  );

  $form['body'] = node_body_field($node, $type->body_label, $type->min_word_count);

  // We need a hidden ckan_id field as the disabled field value isn't passed through to the node.
  // This ckan_id is needed as a key for the api call to update this package.
   $form['ckan_id'] = array(
     '#type' => 'hidden',
     '#value' => $node->ckan['id'],
   );
   $form['ckan_id_display'] = array(
     '#type' => 'textfield',
     '#title' => 'ckan id',
     '#default_value' => $node->ckan['id'],
     '#disabled' => TRUE,
   );

   $form['ckan_name'] = array(
     '#type' => 'textfield',
     '#title' => 'ckan name',
     '#default_value' => $node->ckan['name'],
     '#required' => TRUE,
   );
   $form['ckan_version'] = array(
     '#type' => 'textfield',
     '#title' => 'ckan version',
     '#default_value' => $node->ckan['version'],
   );
   $form['ckan_url'] = array(
     '#type' => 'textfield',
     '#title' => 'ckan url',
     '#default_value' => $node->ckan['url'],
   );
   $form['ckan_author'] = array(
     '#type' => 'textfield',
     '#title' => 'ckan author',
     '#default_value' => $node->ckan['author'],
   );
   $form['ckan_author_email'] = array(
     '#type' => 'textfield',
     '#title' => 'ckan author email',
     '#default_value' => $node->ckan['author_email'],
   );
   $form['ckan_maintainer'] = array(
     '#type' => 'textfield',
     '#title' => 'ckan maintainer',
     '#default_value' => $node->ckan['maintainer'],
   );
   $form['ckan_maintainer_email'] = array(
     '#type' => 'textfield',
     '#title' => 'ckan maintainer email',
     '#default_value' => $node->ckan['maintainer_email'],
   );
   $form['ckan_license_id'] = array(
     '#type' => 'select',
     '#title' => 'ckan license_id',
     '#default_value' => $node->ckan['license_id'],
     '#options' => array(
       '' => '',
       'licensevalue1' => 'license1',
       'licensevalue2' => 'license2',
     ),
   );
   $form['ckan_update_date'] = array(
     '#type' => 'textfield',
     '#title' => 'ckan update_date',
     '#default_value' => $node->ckan['update_date'],
     '#disabled' => TRUE,
   );
   $form['ckan_state'] = array(
     '#type' => 'textfield',
     '#title' => 'ckan state',
     '#default_value' => $node->ckan['state'],
     '#disabled' => TRUE,
   );
   $form['ckan_completed'] = array(
     '#type' => 'textfield',
     '#title' => 'ckan completed',
     '#default_value' => $node->ckan['completed'],
     '#disabled' => TRUE,
   );

  return $form;
}


/**
 * Implementation of hook_load().
 *
 * Now that we've defined how to manage the node data in the database, we
 * need to tell Drupal how to get the node back out. This hook is called
 * every time a node is loaded, and allows us to do some loading of our own.
 */
function ckan_load($node) {
  $sql = "SELECT *
  				FROM {ckan_package}
  				WHERE nid = %d ";
  $additions = db_fetch_array(db_query($sql, $node->nid));

  // Put the loaded information into a ckan key to avoid naming collisions.
  return array('ckan' => $additions);
}


/**
 * Implementation of hook_insert().
 *
 * As a new node is being inserted into the database, we need to do our own
 * database inserts.
 */
function ckan_insert($node) {
  require_once(drupal_get_path('module', 'ckan').'/lib/ckan.lib.inc');
  $ckan = new Ckan('http://127.0.0.1:5000','123456');

  $package= array(
    "nid"              => $node->nid,            //required
    "title"            => $node->title,
    "name"             => $node->ckan_name,
    "version"          => $node->ckan_version,
    "url"              => $node->ckan_url,
    "author"           => $node->ckan_author,
    "author_email"     => $node->ckan_author_email,
    "maintainer"       => $node->ckan_maintainer,
    "maintainer_email" => $node->ckan_maintainer_email,
    "notes"            => $node->body,
    "license_id"       => $node->ckan_license_id,
  );

  try {
     $return = $ckan->createPackage(json_encode($package));
  } catch (Exception $e) {
    form_set_error('', $e->getMessage());

    // Delete node if something has gone wrong
    if (is_numeric($node->nid)) {
      node_delete($node->nid);
    }

  }
}


/**
 * Implementation of hook_update().
 *
 * As an existing node is being updated in the database, we need to do our own
 * database updates.
 */
function ckan_update($node) {
require_once(drupal_get_path('module', 'ckan').'/lib/ckan.lib.inc');
  $ckan = new Ckan('http://127.0.0.1:5000','123456');

  $package= array(
    "id"               => $node->ckan_id,                 //required
    "nid"              => $node->nid,
    "title"            => $node->title,
    "name"             => $node->ckan_name,
    "version"          => $node->ckan_version,
    "url"              => $node->ckan_url,
    "author"           => $node->ckan_author,
    "author_email"     => $node->ckan_author_email,
    "maintainer"       => $node->ckan_maintainer,
    "maintainer_email" => $node->ckan_maintainer_email,
    "notes"            => $node->body,
    "license_id"       => $node->ckan_license_id,
  );

  try {
     $return = $ckan->updatePackage(json_encode($package));
  } catch (Exception $e) {
    form_set_error('', $e->getMessage());

  }
}


/**
 * Implementation of hook_view().
 *
 * This is a typical implementation that simply runs the node text through
 * the output filters.
 */
function ckan_view($node, $teaser = FALSE, $page = FALSE) {
  $node = node_prepare($node, $teaser);
  $node->content['ckan'] = array(
    '#value' => theme('ckan_package_info', $node),
    '#weight' => 1,
  );
  return $node;
}


/**
 * Implementation of hook_delete().
 *
 * When a node is deleted, we need to remove all related records from our table.
 */
function ckan_delete($node) {
  // Notice that we're matching all revision, by using the node's nid.
  db_query('DELETE FROM {ckan_package} WHERE nid = %d', $node->nid);
}


/**
 * Implementation of hook_theme().
 *
 * This lets us tell Drupal about our theme functions and their arguments.
 */
function ckan_theme() {
  return array(
    'ckan_package_info' => array(
      'arguments' => array('node'),
    ),
  );
}


/**
 * A custom theme function.
 *
 * By using this function to format our node-specific information, themes
 * can override this presentation if they wish. We also wrap the default
 * presentation in a CSS class that is prefixed by the module name. This
 * way, style sheets can modify the output without requiring theme code.
 */
function theme_ckan_package_info($node) {
  $output = '<div class="ckan_package_info">';

  foreach ($node->ckan as $key => $value) {
    $output .= "<p>";
    $output .= t('%keyname : %value ', array('%keyname' => check_plain($key), '%value' => check_plain($value) ));
    $output .= "</p>";
  }
  $output .= '</div>';
  return $output;
}

